#0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

# ---- INPUT PATHS ----
root_dir  <- getwd()
meta_dir  <- normalizePath("C:/Users/User/Documents/metadata", winslash = "/")

cel_files <- list.files(meta_dir, pattern = "\\.CEL$", full.names = TRUE)
pheno_csv <- file.path(meta_dir, "pheno.csv")

# (opsiyonel) pheno dosyası varsa oku
if (file.exists(pheno_csv)) {
  pheno <- read.csv(pheno_csv, stringsAsFactors = FALSE)
}

# Affymetrix okumaları
library(affy)  # veya oligo platformuna göre
raw <- ReadAffy(filenames = cel_files)
# ... RMA, QC, batch correction, limma vs. burada devam ...

packages <- c(
  "pkgbuild", "AnnotationDbi", "Biobase", "DOSE", "GEOquery", "GOSemSim", "R.utils",
  "affy", "annotate", "clusterProfiler", "data.table", "dplyr", "enrichplot",
  "genefilter", "ggplot2", "ggrepel", "grid", "gridExtra", "hgu133plus2.db",
  "jsonlite", "limma", "msigdbr", "multiMiR", "org.Hs.eg.db", "pheatmap",
  "sva", "umap", "STRINGdb", "igraph", "ggraph", "tidygraph"
)

#------------------------   Load required packages; assumes they are already installed   ----------------------

invisible(lapply(packages, library, character.only = TRUE))

if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
BiocManager::install("multiMiR")

align_samples <- function(cel_files, pheno) {
  sample_names <- basename(cel_files)
  pheno_df <- as.data.frame(pheno, stringsAsFactors = FALSE)
  pheno_keys <- toupper(basename(trimws(pheno_df$filename)))
  sample_keys <- toupper(sample_names)
  idx <- match(sample_keys, pheno_keys)
  if (any(is.na(idx))) {
    stop("pheno$filename içinde bulunamayan örnek(ler): ",
         paste(sample_names[is.na(idx)], collapse = ", "))
  }
  aligned <- pheno_df[idx, , drop = FALSE]
  rownames(aligned) <- sample_names
  stopifnot(nrow(aligned) == length(sample_names))
  stopifnot(identical(rownames(aligned), sample_names))
  aligned
}

pkgbuild::has_build_tools(debug = TRUE)

args <- commandArgs(trailingOnly = TRUE)
FDR_THRESH   <- if (length(args) >= 1) as.numeric(args[1]) else 0.1
LOGFC_THRESH <- if (length(args) >= 2) as.numeric(args[2]) else 0.5

# ---- utils: NULL-coalescing ve güvenli multiMiR çekici ----
`%||%` <- function(x, y) if (is.null(x)) y else x

safe_multimir_table <- function(targets, table = c("validated","predicted"),
                                chunk_size = 500, timeout_sec = 120) {
  table <- match.arg(table)
  if (!requireNamespace("R.utils", quietly = TRUE)) install.packages("R.utils")
  n <- length(targets); if (n == 0) return(NULL)
  idx <- split(seq_len(n), ceiling(seq_len(n) / chunk_size))
  out <- vector("list", length(idx))
  for (i in seq_along(idx)) {
    tg <- unique(targets[idx[[i]]])
    message(sprintf("multiMiR '%s' chunk %d/%d (n=%d)", table, i, length(idx), length(tg)))
    flush.console()
    mm <- try(
      R.utils::withTimeout(
        multiMiR::get_multimir(org = "hsa", target = tg, table = table, summary = FALSE),
        timeout = timeout_sec, onTimeout = "silent"
      ),
      silent = TRUE
    )
    if (inherits(mm, "try-error") || is.null(mm)) next
    if (!methods::is(mm, "multiMiR") || nrow(mm@data) == 0) next
    out[[i]] <- mm@data
  }
  if (all(vapply(out, is.null, logical(1)))) return(NULL)
  do.call(rbind, out)
}

#-----------------------------   Load CEL files and normalize with RMA    ---------------------------------------------

root_dir <- normalizePath(Sys.getenv("POMPE_ROOT", getwd()), winslash = "/")
meta_dir <- normalizePath("C:/Users/User/Documents/metadata", winslash = "/")

stopifnot(dir.exists(meta_dir))

dir.create(file.path(root_dir, "results", "qc"),    recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(root_dir, "results", "deg"),   recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(root_dir, "results", "plots"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(root_dir, "results", "miRNA_analysis"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(root_dir, "logs"),             recursive = TRUE, showWarnings = FALSE)

writeLines(c(capture.output(sessionInfo())), file.path(root_dir, "logs", "session_info.txt"))

set.seed(20240724)

pheno <- data.table::fread(file.path(meta_dir, "pheno.csv"),
                           na.strings = c("", "NA", "NaN"))

pheno$filename <- basename(trimws(pheno$filename))
cel_dir   <- meta_dir
cel_files <- file.path(cel_dir, pheno$filename)
missing   <- pheno$filename[!file.exists(cel_files)]
if (length(missing)) stop("Missing CEL files in metadata/: ", paste(missing, collapse = ", "))

stopifnot(all(c("sample","group","filename") %in% names(pheno)))
g <- tolower(trimws(as.character(pheno$group)))
g[g %in% c("control","healthy","normal")] <- "control"
g[grepl("pompe", g)] <- "pompe"
pheno$group <- factor(ifelse(g %in% c("control","pompe"),
                             ifelse(g == "control","Control","Pompe"), NA_character_),
                      levels = c("Control","Pompe"))
stopifnot(!any(is.na(pheno$group)))

## --- GROUP etiketlerini normalize et ---
g <- tolower(trimws(as.character(pheno$group)))
g[g %in% c("control", "healthy", "normal", "ctrl", "cntrl")] <- "Control"
g[g %in% c("pompe", "case", "patient")]                     <- "Pompe"
pheno$group <- factor(g, levels = c("Control", "Pompe"))
stopifnot(!any(is.na(pheno$group)))


## CEL ↔ pheno eşleşmesi (case-insensitive, trim)
cel_keys   <- toupper(basename(trimws(cel_files)))
pheno_keys <- toupper(basename(trimws(pheno$filename)))
idx <- match(cel_keys, pheno_keys)
if (anyNA(idx)) {
  missing <- cel_keys[is.na(idx)]
  stop("pheno$filename içinde bulunamayan örnek(ler): ", paste(missing, collapse=", "))
}
aligned <- pheno[idx, , drop = FALSE]
rownames(aligned) <- cel_keys
stopifnot(identical(rownames(aligned), cel_keys))

#AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA


## === 0) CEL dosyalarını bul ===
cel_dir <- "C:/Users/User/Documents/metadata"   # CEL'lerin gerçek yolu buysa
# Alternatif: cel_dir <- file.path(root_dir, "data", "CEL")

cel_files <- list.files(
  cel_dir,
  pattern   = "(?i)\\.CEL(\\.gz)?$",
  full.names = TRUE,
  recursive  = FALSE   # alt klasörlerde aramak istersen TRUE yap
)
stopifnot(length(cel_files) > 0)

## === 1) Oku (Affy) ve RMA uygula ===
suppressPackageStartupMessages({
  library(affy); library(Biobase)
})
raw  <- ReadAffy(filenames = cel_files)
eset <- rma(raw)   # log2, quantile norm, median polish




## pheno ~ CEL hizalamasını zaten yaptın:
# aligned <- pheno[idx, , drop = FALSE]
# rownames(aligned) <- cel_keys  # (zaten var)

## ---> BURAYI EKLE
pheno_aligned <- as.data.frame(aligned, stringsAsFactors = FALSE)

## eset örnek adları = CEL dosya adları (ids/cel_keys)
ids <- toupper(basename(trimws(cel_files)))
Biobase::sampleNames(eset) <- ids

## pheno_aligned satır adları da aynı olsun
rownames(pheno_aligned) <- ids

## ExpressionSet içine yaz
Biobase::pData(eset) <- pheno_aligned

## İfade matrisi ve kontrol
expr <- Biobase::exprs(eset)
stopifnot(identical(colnames(expr), rownames(pheno_aligned)))



## === 2) Örnek adlarını pheno ile bire bir hizala ===
# Örnek adlarını standart formata (BASENAME + UPPERCASE) getir
ids <- toupper(basename(trimws(cel_files)))
sampleNames(eset) <- ids

# pheno_aligned$filename anahtarını aynı kurala sok
ph_keys <- toupper(basename(trimws(pheno_aligned$filename)))

# Tüm örneklerin pheno'da karşılığı var mı?
m <- match(sampleNames(eset), ph_keys)
stopifnot(!any(is.na(m)))

# pheno_aligned'ı eset sırasına göre diz ve ExpressionSet'e aktar
pheno_aligned <- pheno_aligned[m, , drop = FALSE]
rownames(pheno_aligned) <- sampleNames(eset)
Biobase::pData(eset) <- pheno_aligned

# İfade matrisi
expr <- Biobase::exprs(eset)   # [probe x örnek]

# Sütun adları (örnekler) ile pheno satır adları bire bir mi?
if (!identical(colnames(expr), rownames(pheno_aligned))) {
  expr <- expr[, rownames(pheno_aligned), drop = FALSE]  # gerekirse sırala
}
stopifnot(identical(colnames(expr), rownames(pheno_aligned)))

## === 3) Tasarım matrisi (limma için) ===
# Grup yönünü sabitle (kontrastlar için önemlidir)
pheno_aligned$group <- factor(pheno_aligned$group, levels = c("Control","Pompe"))
design <- model.matrix(~ 0 + group, data = pheno_aligned)   # Interceptsiz
stopifnot(ncol(expr) == nrow(design))

## === 4) (Opsiyonel) ComBat batch düzeltmesi ===
# ComBat'ı sadece anlamlı bir batch çeşitliliği varsa çalıştır
use_combat <- ("batch" %in% names(pheno_aligned)) &&
  (!all(is.na(pheno_aligned$batch))) &&
  (length(unique(pheno_aligned$batch)) > 1)

if (use_combat) {
  suppressPackageStartupMessages(library(sva))
  batch <- factor(ifelse(is.na(pheno_aligned$batch), "NA", as.character(pheno_aligned$batch)))
  mod   <- design  # biyolojik etkiyi koru
  expr_cb <- ComBat(dat = expr, batch = batch, mod = mod,
                    par.prior = TRUE, prior.plots = FALSE)
  expr <- expr_cb
}
# Bu noktada 'expr' nihai ifade matrisi (ComBat uygulanmış ya da ham RMA) olarak kullanılabilir.

## === 5) Güvenlik kontrolleri (önerilir) ===
stopifnot(ncol(expr) == nrow(pheno_aligned))
stopifnot(ncol(expr) == nrow(design))

# NOT: Bu blok MELAS duyarlılık altkümesini oluşturmaz.
# MELAS filtresi (specialcase/is_melas) ile "hariç" ve "dahil" senaryolarını
# bu blok SONRASINDA kurup aynı design/lmFit/eBayes akışını koşturmalısın.

#BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB

# 1) pheno'yu pData(eset)'ten al (tek kaynak)
ph <- Biobase::pData(eset)

# 2) Tip/Seviye düzelt
ph$group <- factor(ph$group, levels = c("Control","Pompe"))
if ("age_at_baseline_mounth" %in% names(ph)) {
  ph$age_at_baseline_mounth <- suppressWarnings(
    as.numeric(gsub(",", ".", trimws(ph$age_at_baseline_mounth)))
  )
}
if ("sex" %in% names(ph)) {
  sx <- toupper(trimws(as.character(ph$sex)))
  sx[sx %in% c("FEMALE","WOMAN","K","KADIN")] <- "F"
  sx[sx %in% c("MALE","MAN","E","ERKEK")]      <- "M"
  ph$sex <- factor(sx, levels = c("F","M"))
}

# 3) MELAS türet (specialcase öncelikli)
if ("specialcase" %in% names(ph)) {
  melas_log <- trimws(as.character(ph$specialcase)) %in% c("1", 1, TRUE, "TRUE", "Yes", "YES", "MELAS")
} else if ("is_melas" %in% names(ph)) {
  melas_log <- ph$is_melas %in% c("Yes","YES",TRUE,1,"MELAS")
} else {
  melas_log <- rep(FALSE, nrow(ph))
}
ph$is_melas <- factor(ifelse(melas_log, "Yes", "No"), levels = c("No","Yes"))

# 4) Anotasyon (ısı haritası vb.)
ann_col <- data.frame(
  Group = ph$group,
  Batch = if ("batch" %in% names(ph)) ph$batch else NA,
  MELAS = ph$is_melas,
  row.names = rownames(ph)
)

# 5) MELAS hariç altküme (duyarlılık analizi)
keep <- which(ph$is_melas == "No")
ph_s <- droplevels(ph[keep, , drop = FALSE])
expr_s <- expr[, rownames(ph_s), drop = FALSE]         # <— expr ile bire bir!
design_s <- model.matrix(~ 0 + group, data = ph_s)

# 6) Meta özet
meta_info <- list(
  dataset   = "GSE38680",
  n_total   = nrow(ph),
  n_control = sum(ph$group == "Control"),
  n_pompe   = sum(ph$group == "Pompe"),
  n_melas   = sum(ph$is_melas == "Yes")
)

# (Opsiyonel) pData(eset)'i geri yaz (temiz hali)
Biobase::pData(eset) <- ph

# Son güvenlik:
stopifnot(identical(colnames(expr), rownames(ph)))
stopifnot(identical(colnames(expr_s), rownames(ph_s)))

# 8) Son güvenlik kontrolleri
stopifnot(identical(colnames(expr),   rownames(ph)))
stopifnot(identical(colnames(expr_s), rownames(ph_s)))

#CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

## Paketler
suppressPackageStartupMessages({
  library(limma)
  library(AnnotationDbi)
  library(hgu133plus2.db)
  library(dplyr); library(magrittr)
  library(msigdbr); library(clusterProfiler)
  library(ggplot2); library(umap)
})

## 0) Analizde kullanılacak KANONİK ifade matrisi
## (A/B aşamasından sonra 'expr' varsa ComBat/SVA sonrası demektir; yoksa RMA'dan al)
expr_mat <- if (exists("expr")) expr else Biobase::exprs(eset)
stopifnot(identical(colnames(expr_mat), rownames(pheno_aligned)))

## 1) Tasarım & limma
# Kolon adlarını düz set etmek kontrast yazımını kolaylaştırır
design <- model.matrix(~0 + group, data = pheno_aligned)
colnames(design) <- levels(pheno_aligned$group)  # "Control","Pompe"
stopifnot(ncol(expr_mat) == nrow(design))

fit  <- limma::lmFit(expr_mat, design)
cont <- limma::makeContrasts(PompeVsControl = Pompe - Control, levels = design)
fit2 <- limma::eBayes(limma::contrasts.fit(fit, cont))
tt   <- limma::topTable(fit2, number = Inf, sort.by = "P")  # rownames = PROBEID

## 2) Anotasyon (U133 Plus 2.0)
probe_ids <- rownames(tt)
ann <- AnnotationDbi::select(hgu133plus2.db,
                             keys = probe_ids,
                             columns = c("SYMBOL","ENTREZID"),
                             keytype = "PROBEID") %>%
  distinct(PROBEID, .keep_all = TRUE)

tt$PROBEID <- rownames(tt)
tt_gene <- dplyr::left_join(tt, ann, by = "PROBEID")

## 3) Gen düzeyinde tekilleştirme (|t| en büyük prob)
ranks_tbl <- tt_gene %>%
  filter(!is.na(SYMBOL), SYMBOL != "", is.finite(t)) %>%
  mutate(SYMBOL = toupper(SYMBOL)) %>%
  group_by(SYMBOL) %>%
  slice_max(order_by = abs(t), n = 1, with_ties = FALSE) %>%
  ungroup()

ranks <- setNames(ranks_tbl$t, ranks_tbl$SYMBOL)
ranks <- sort(ranks, decreasing = TRUE)

## 4) Hallmark GSEA (TERM2GENE)
term2gene <- msigdbr(species = "Homo sapiens", category = "H") %>%
  transmute(term = gs_name, gene = toupper(gene_symbol)) %>%
  distinct()

common <- intersect(names(ranks), term2gene$gene)
if (length(common) < 50) warning("GSEA için ortak gen sayısı düşük: ", length(common))

gsea_h <- clusterProfiler::GSEA(
  geneList  = ranks[common],
  TERM2GENE = term2gene[term2gene$gene %in% common, ],
  verbose   = FALSE
)

## 5) KEGG GSEA (ENTREZ)
## 5) KEGG GSEA (ENTREZ) — SAĞLAM BLOK
# ==== KEGG GSEA (ENTREZ) — TEMİZ BLOK ====

suppressPackageStartupMessages({
  library(dplyr); library(AnnotationDbi); library(hgu133plus2.db)
  library(clusterProfiler)
})

#0tt_gene yoksa, tt ve anotasyonla üret

if (!exists("tt_gene")) {
  stopifnot(exists("tt"), nrow(tt) > 0)
  tt$PROBEID <- rownames(tt)
  ann <- AnnotationDbi::select(hgu133plus2.db,
                               keys    = tt$PROBEID,
                               keytype = "PROBEID",
                               columns = c("SYMBOL","ENTREZID"))
  ann <- ann[!duplicated(ann$PROBEID), ]
  tt_gene <- dplyr::left_join(tt, ann, by = "PROBEID")
}

# 1) ENTREZ ve t-istatistiği (aynı ENTREZ için |t| en büyük olanı tut)
eg_tbl <- tt_gene %>%
  filter(!is.na(ENTREZID), is.finite(t)) %>%
  transmute(ENTREZID = as.character(ENTREZID), t = as.numeric(t)) %>%
  group_by(ENTREZID) %>%
  slice_max(order_by = abs(t), n = 1, with_ties = FALSE) %>%
  ungroup()

# 2) KEGG geneList: ad = ENTREZID, değer = t
eg_ranks <- setNames(eg_tbl$t, eg_tbl$ENTREZID)
eg_ranks <- eg_ranks[is.finite(eg_ranks) & !is.na(names(eg_ranks))]
eg_ranks <- sort(eg_ranks, decreasing = TRUE)   # <-- isimleri korur; as.numeric YAPMAYIN

cat("KEGG için ENTREZ sayısı:", length(eg_ranks), "\n")

# 3) gseKEGG
gse_kegg <- NULL
if (length(eg_ranks) >= 50) {
  gse_kegg <- tryCatch({
    clusterProfiler::gseKEGG(
      geneList  = eg_ranks,
      organism  = "hsa",
      keyType   = "ncbi-geneid",   # ENTREZ kullanıyoruz
      minGSSize = 10,
      verbose   = FALSE
    )
  }, error = function(e) { warning("KEGG GSEA hatası: ", e$message); NULL })
} else {
  warning("KEGG GSEA için yeterli ENTREZID yok: ", length(eg_ranks))
}

if (!is.null(gse_kegg) && nrow(as.data.frame(gse_kegg)) > 0) {
  print(head(as.data.frame(gse_kegg)))
}

## 6) QC – PCA & UMAP (kanonik matrisle)
pca_df <- data.frame(
  PC1 = prcomp(t(expr_mat), scale. = TRUE)$x[,1],
  PC2 = prcomp(t(expr_mat), scale. = TRUE)$x[,2],
  Group = pheno_aligned$group,
  Sample = rownames(pheno_aligned)
)

p_pca <- ggplot(pca_df, aes(PC1, PC2, color = Group, label = Sample)) +
  geom_point(size = 2) + theme_bw(base_size = 14) +
  labs(title = "PCA – Kanonik ifade (RMA ± ComBat)")

um <- umap::umap(t(expr_mat), n_neighbors = 8, random_state = 123)
ump_df <- data.frame(
  Sample = colnames(expr_mat),
  UMAP1  = um$layout[,1],
  UMAP2  = um$layout[,2]
)
ump_df$Group <- pheno_aligned$group[match(ump_df$Sample, rownames(pheno_aligned))]

p_umap <- ggplot(ump_df, aes(UMAP1, UMAP2, color = Group, label = Sample)) +
  geom_point(size = 2) + theme_minimal(base_size = 13) +
  labs(title = "UMAP – Kanonik ifade (RMA ± ComBat)")

## 7) (Opsiyonel) no-MELAS GSEA
if (exists("tt_gene_s")) {
  ranks_s <- tt_gene_s %>%
    filter(!is.na(SYMBOL), SYMBOL != "", is.finite(t)) %>%
    mutate(SYMBOL = toupper(SYMBOL)) %>%
    arrange(desc(abs(t))) %>%            # tekilleştirme yapılmışsa gerekmez
    { setNames(.$t, .$SYMBOL) }
  if (length(ranks_s) >= 50) {
    common_s <- intersect(names(ranks_s), term2gene$gene)
    gsea_h_s <- clusterProfiler::GSEA(
      geneList  = ranks_s[common_s],
      TERM2GENE = term2gene[term2gene$gene %in% common_s, ],
      verbose   = FALSE
    )
  } else message("no-MELAS GSEA atlandı: yeterli rank yok.")
}

## 8) (Opsiyonel) multiMiR – validated hedefler
# Eğer 'safe_multimir_table' tanımlı DEĞİLSE, aşağıdaki örnek çalışır:
# suppressPackageStartupMessages(library(multiMiR))
# universe_set <- unique(tt_gene$SYMBOL[!is.na(tt_gene$SYMBOL)])
# universe_set <- unique(tt_gene$SYMBOL[tt_gene$adj.P.Val < 0.05])  # sadece DEGs için
# mm <- multiMiR::get_multimir(org = "hsa", target = universe_set, table = "validated", summary = TRUE)
# df <- multiMiR::multimir_results(mm)

#ON KONTROL
packageVersion("multiMiR")
names(formals(multiMiR::get_multimir))
curl::has_internet()
#length(universe_set) #NEDEN ÇALIŞMADI BUL
try(multiMiR::get_multimir(org="hsa", target="TP53", table="validated", summary=FALSE))

suppressPackageStartupMessages({ library(multiMiR); library(dplyr); library(R.utils) })

.extract_validated_df <- function(mm) {
  if (is.null(mm) || inherits(mm, "try-error")) return(NULL)
  # yeni API (S4)
  if (methods::is(mm, "mmquery") && "data" %in% slotNames(mm)) {
    dd <- mm@data
    if (methods::is(dd, "mmdata") && "validated" %in% slotNames(dd)) {
      df <- try(as.data.frame(dd@validated), silent = TRUE)
      if (!inherits(df, "try-error")) return(df)
    }
  }
  # ortak/legacy yol
  df <- try(multiMiR::multimir_results(mm), silent = TRUE)
  if (!inherits(df, "try-error")) df else NULL
}

get_validated_mm <- function(targets,
                             # bu kaynaklara sonradan 'database' ile filtre uygular
                             sources = c("mirtarbase","mirecords","tarbase"),
                             chunk_size = 500,
                             timeout_sec = 120) {
  tg <- unique(na.omit(toupper(as.character(targets))))
  if (!length(tg)) return(NULL)
  
  gm_args <- names(formals(multiMiR::get_multimir))
  allow_legacy_out <- "legacy.out" %in% gm_args
  
  idx <- split(seq_along(tg), ceiling(seq_along(tg)/chunk_size))
  out <- vector("list", length(idx))
  
  for (i in seq_along(idx)) {
    sub <- tg[idx[[i]]]
    message(sprintf("[validated] chunk %d/%d (n=%d)", i, length(idx), length(sub)))
    
    call_list <- list(org="hsa", target=sub, table="validated", summary=FALSE)
    if (allow_legacy_out) call_list$legacy.out <- TRUE
    
    mm <- try(
      R.utils::withTimeout(do.call(multiMiR::get_multimir, call_list),
                           timeout = timeout_sec, onTimeout = "silent"),
      silent = TRUE
    )
    if (inherits(mm, "try-error") || is.null(mm)) { message("  ↳ get_multimir başarısız."); next }
    df <- .extract_validated_df(mm)
    if (!is.null(df) && nrow(df)) {
      if ("database" %in% names(df)) df <- df[df$database %in% sources, , drop=FALSE]
      out[[i]] <- df
    } else message("  ↳ validated tablo boş.")
  }
  
  res <- dplyr::bind_rows(Filter(Negate(is.null), out))
  if (!nrow(res)) return(NULL)
  
  # isimleri normalize
  if (!"mature_mirna_id" %in% names(res) && "mature_mirna_acc" %in% names(res))
    res$mature_mirna_id <- res$mature_mirna_acc
  tgt_col <- intersect(c("target_symbol","target","SYMBOL","gene"), names(res))[1]
  if (!is.na(tgt_col)) res[[tgt_col]] <- toupper(trimws(res[[tgt_col]]))
  
  # miRNA–gen–veritabanı tekilleştirme
  key_cols <- intersect(c(tgt_col,"mature_mirna_id","database"), names(res))
  res <- dplyr::distinct(res, dplyr::across(all_of(key_cols)), .keep_all = TRUE)
  res
}

# Evren = anlamlı gen sembolleri
universe_set <- unique(tt_gene$SYMBOL[!is.na(tt_gene$SYMBOL) & tt_gene$adj.P.Val < FDR_THRESH])
universe_set <- toupper(universe_set)

mm_val <- get_validated_mm(universe_set, chunk_size = 500, timeout_sec = 120)

if (is.null(mm_val) || !nrow(mm_val)) {
  message("Validated sonuc gelmedi (ag/surum k olabilir).")
} else {
  tgt_col <- intersect(c("target_symbol","target","SYMBOL","gene"), colnames(mm_val))[1]
  mm_val  <- mm_val[toupper(mm_val[[tgt_col]]) %in% universe_set, , drop=FALSE]
  
  cat("Toplam kayıt:", nrow(mm_val),
      " | Gen:", length(unique(mm_val[[tgt_col]])),
      " | miRNA:", if ("mature_mirna_id" %in% names(mm_val)) length(unique(mm_val$mature_mirna_id)) else NA, "\n")
}

## 9) Kontroller BURADA SORUN YAŞARSAN SİL

if (!is.null(mm_val)) {
  cat("Toplam kayıt:", nrow(mm_val),
      " | Gen:", length(unique(mm_val$target_symbol)),
      " | miRNA:", length(unique(mm_val$mature_mirna_id)), "\n")
}

cat("Hallmark GSEA ortak gen:", length(common), "\n")
cat("KEGG ENTREZ ranks:", length(eg_ranks), "\n")
cat("Design boyutu: ", nrow(design), " örnek x ", ncol(design), " değişken\n", sep = "")
cat("QC ve analiz blokları tamamlandı.\n")


## ===========================================================
## E BLOĞU: Predicted miRNA–Hedef (TargetScan HARIÇ) + Görseller
## Yer: C (drop-in: limma+anotasyon+GSEA) sonrasında
## Girdi varsayımları: 'tt_gene' (SYMBOL, adj.P.Val) mevcut.
## ===========================================================

#suppressPackageStartupMessages({
#  library(multiMiR)
#  library(AnnotationDbi)
#  library(org.Hs.eg.db)
#  library(dplyr); library(stringr)
#  library(ggplot2); library(igraph); library(ggraph); library(pheatmap)
#})

## ---------- 0) SIG genleri güvenle hazırla ----------
if (!exists("tt_gene")) {
  # Son çare: tt_treat / tt / tt_noM'den üret
  src <- if (exists("tt_treat")) tt_treat else if (exists("tt_noM")) tt_noM else if (exists("tt")) tt else NULL
  stopifnot(!is.null(src) && nrow(src) > 0)
  if (!"SYMBOL" %in% names(src)) {
    src$PROBEID <- rownames(src)
    ann <- AnnotationDbi::select(hgu133plus2.db,
                                 keys = src$PROBEID,
                                 keytype = "PROBEID",
                                 columns = c("SYMBOL","ENTREZID")) |>
      distinct(PROBEID, .keep_all = TRUE)
    src <- src |> left_join(ann, by = "PROBEID")
  }
  tt_gene <- src |>
    filter(!is.na(SYMBOL), nzchar(SYMBOL)) |>
    group_by(SYMBOL) |>
    slice_min(order_by = adj.P.Val, n = 1, with_ties = FALSE) |>
    ungroup()
}

sig_genes <- tt_gene |> filter(adj.P.Val < 0.1, !is.na(SYMBOL), nzchar(SYMBOL)) |> pull(SYMBOL) |> unique()
sig_genes <- toupper(na.omit(sig_genes))
if (length(sig_genes) == 0L) {
  warning("Predicted blok atlandı: adj.P.Val < 0.1 ile anlamlı gen yok.")
}

## ---------- 1) multiMiR çıktısını güvenle df'e çeviren yardımcı ----------
extract_predicted_df <- function(mm) {
  # 1) data.frame ise
  if (is.data.frame(mm)) return(mm)
  # 2) Liste varyantları
  if (is.list(mm)) {
    cand <- mm[intersect(names(mm), c("data","predicted","results"))]
    if (length(cand)) {
      dd <- cand[[1]]
      if (methods::is(dd, "mmdata") && "predicted" %in% slotNames(dd)) return(as.data.frame(dd@predicted))
      if (is.data.frame(dd)) return(dd)
    }
  }
  # 3) Klasik S4 (mmquery)
  if (methods::is(mm, "mmquery") && "data" %in% slotNames(mm)) {
    dd <- mm@data
    if (methods::is(dd, "mmdata") && "predicted" %in% slotNames(dd)) return(as.data.frame(dd@predicted))
    if (is.data.frame(dd)) return(dd)
  }
  stop("get_multimir çıktısı beklenen yapıda değil (data/predicted bulunamadı).")
}

## ---------- 2) TargetScan hariç predicted sorgu ----------
## ---------- 2) TargetScan hariç predicted sorgu (chunk ve timeout'lu) ----------
get_predicted_no_targetscan_chunked <- function(target_vec,
                                                chunk_size = 50,
                                                timeout_sec = 120,
                                                sites = c("diana_microt","elmmo","microcosm","miranda","mirdb","pictar","pita")) {
  target_vec <- unique(na.omit(toupper(as.character(target_vec))))
  if (!length(target_vec)) return(NULL)
  idx <- split(seq_along(target_vec), ceiling(seq_along(target_vec) / chunk_size))
  out <- vector("list", length(idx))
  for (i in seq_along(idx)) {
    sub <- target_vec[idx[[i]]]
    message(sprintf("[predicted] chunk %d/%d (n=%d)", i, length(idx), length(sub)))
    tries <- list(
      sites,
      c("mirdb","miranda","pita"),
      "mirdb"
    )
    res <- NULL
    for (ss in tries) {
      res <- try(
        R.utils::withTimeout(
          multiMiR::get_multimir(
            org = "hsa",
            target = sub,
            table = "predicted",
            predicted.site = ss,
            predicted.cutoff.type = "p",
            predicted.cutoff      = 1.0,
            summary    = FALSE,
            legacy.out = TRUE
          ),
          timeout = timeout_sec, onTimeout = "silent"
        ),
        silent = TRUE
      )
      if (!inherits(res, "try-error") && !is.null(res)) {
        df <- try(extract_predicted_df(res), silent = TRUE)
        if (!inherits(df, "try-error") && !is.null(df) && nrow(df) > 0) {
          out[[i]] <- df
          break
        }
      }
    }
    if (is.null(out[[i]])) message(sprintf("  ↳ predicted tablo chunk %d boş.", i))
  }
  tab <- dplyr::bind_rows(Filter(Negate(is.null), out))
  if (!nrow(tab)) {
    message("Predicted sorgusu sonucunda tablo tamamen boş döndü!")
    return(NULL)
  }
  tab
}

## ---------- 3) Sorgu: önce SYMBOL, boşsa ENTREZ fallback ----------
mm_net_predicted <- NULL
if (length(sig_genes) > 0) {
  genes_sym <- unique(na.omit(toupper(as.character(sig_genes))))
  mm_net_predicted <- get_predicted_no_targetscan_chunked(genes_sym)
  
  if (is.null(mm_net_predicted) || nrow(mm_net_predicted) == 0) {
    # ENTREZID'a düş
    map_ent   <- AnnotationDbi::select(org.Hs.eg.db, keys = genes_sym,
                                       keytype = "SYMBOL", columns = "ENTREZID")
    genes_ent <- unique(na.omit(as.character(map_ent$ENTREZID)))
    if (length(genes_ent)) {
      mm_net_predicted <- get_predicted_no_targetscan_chunked(genes_ent)
      # ENTREZ döndüyse okunabilirlik için SYMBOL ekle
      if (!is.null(mm_net_predicted) && nrow(mm_net_predicted) > 0 &&
          "target_entrez" %in% names(mm_net_predicted) &&
          !("target_symbol" %in% names(mm_net_predicted))) {
        map_sym <- AnnotationDbi::select(org.Hs.eg.db,
                                         keys = unique(as.character(mm_net_predicted$target_entrez)),
                                         keytype = "ENTREZID", columns = "SYMBOL")
        mm_net_predicted <- dplyr::left_join(mm_net_predicted, map_sym,
                                             by = c("target_entrez" = "ENTREZID"))
        names(mm_net_predicted)[names(mm_net_predicted) == "SYMBOL"] <- "target_symbol"
      }
    }
  }
}

if (is.null(mm_net_predicted) || nrow(mm_net_predicted) == 0) {
  warning("Predicted miRNA–hedef bulunamadı; görselleştirmeler atlandı.")
} else {
  
  ## ---------- 4) Hedef ve miRNA kolonlarını bul, normalize et ----------
  target_col <- dplyr::case_when(
    "target_symbol" %in% names(mm_net_predicted) ~ "target_symbol",
    "SYMBOL"        %in% names(mm_net_predicted) ~ "SYMBOL",
    "gene"          %in% names(mm_net_predicted) ~ "gene",
    TRUE ~ NA_character_
  )
  if (is.na(target_col)) stop("Predicted tabloda hedef sütun yok (target_symbol/SYMBOL/gene).")
  
  mirna_candidates <- c("mature_mirna_id","miRNA","mirna","mirna_id","miRNA_ID","mature_mirna_acc")
  mirna_col <- intersect(mirna_candidates, names(mm_net_predicted))[1]
  if (is.na(mirna_col)) stop("miRNA kimliği için beklenen kolon bulunamadı.")
  
  mm_net_predicted[[target_col]] <- toupper(trimws(as.character(mm_net_predicted[[target_col]])))
  mm_net_predicted[[mirna_col]]  <-        trimws(as.character(mm_net_predicted[[mirna_col]]))
  mm_net_predicted <- mm_net_predicted[ mm_net_predicted[[target_col]] %in% sig_genes, , drop = FALSE]
  
  if (nrow(mm_net_predicted) == 0) {
    warning("Anlamlı genlerle kesişen predicted kayıt yok; görselleştirmeler atlandı.")
  } else {
    
    ## ---------- 5) Çıktı klasörü ----------
    if (!exists("plot_dir") || is.null(plot_dir)) {
      plot_dir <- file.path(getwd(), "plots")
    }
    dir.create(plot_dir, recursive = TRUE, showWarnings = FALSE)
    save_gg <- function(p, fname, w = 9, h = 6, dpi = 300)
      ggplot2::ggsave(filename = file.path(plot_dir, fname), plot = p, width = w, height = h, dpi = dpi)
    
    ## ---------- 6) En çok hedeflenen genler (barplot) ----------
    gene_freq <- as.data.frame(table(mm_net_predicted[[target_col]], useNA = "no"))
    colnames(gene_freq) <- c("Gene", "Count")
    gene_freq <- gene_freq[order(-gene_freq$Count), , drop = FALSE]
    top_genes <- utils::head(gene_freq, min(20, nrow(gene_freq)))
    
    p_genes <- ggplot2::ggplot(top_genes, ggplot2::aes(x = reorder(Gene, Count), y = Count)) +
      ggplot2::geom_bar(stat = "identity") +
      ggplot2::coord_flip() +
      ggplot2::labs(title = "Predicted: En Çok Hedeflenen Genler", x = "Gen", y = "miRNA Sayısı") +
      ggplot2::theme_minimal(base_size = 14)
    
    save_gg(p_genes, "predicted_top_targeted_genes.png")
    utils::write.csv(top_genes, file.path(plot_dir, "predicted_top_targeted_genes.csv"), row.names = FALSE)
    
    ## ---------- 7) En çok gen hedefleyen miRNA’lar (barplot) ----------
    mir_freq <- as.data.frame(table(mm_net_predicted[[mirna_col]], useNA = "no"))
    colnames(mir_freq) <- c("miRNA", "Count")
    mir_freq <- mir_freq[order(-mir_freq$Count), , drop = FALSE]
    top_mirnas <- utils::head(mir_freq, min(20, nrow(mir_freq)))
    
    p_mir <- ggplot2::ggplot(top_mirnas, ggplot2::aes(x = reorder(miRNA, Count), y = Count)) +
      ggplot2::geom_bar(stat = "identity") +
      ggplot2::coord_flip() +
      ggplot2::labs(title = "Predicted: En Çok Gen Hedefleyen miRNA'lar", x = "miRNA", y = "Gen Sayısı") +
      ggplot2::theme_minimal(base_size = 14)
    
    save_gg(p_mir, "predicted_top_targeting_miRNAs.png")
    utils::write.csv(top_mirnas, file.path(plot_dir, "predicted_top_targeting_miRNAs.csv"), row.names = FALSE)
    
    ## ---------- 8) Alt-ağ (top-30 gen & top-30 miRNA) ----------
    suppressPackageStartupMessages({ library(igraph); library(ggraph) })
    top_genes_vec  <- utils::head(gene_freq$Gene, min(30, nrow(gene_freq)))
    top_mirnas_vec <- utils::head(mir_freq$miRNA,  min(30, nrow(mir_freq)))
    
    edges_sub <- mm_net_predicted[
      mm_net_predicted[[target_col]] %in% top_genes_vec &
        mm_net_predicted[[mirna_col]]  %in% top_mirnas_vec,
      c(target_col, mirna_col), drop = FALSE
    ]
    colnames(edges_sub) <- c("Gene", "miRNA")
    edges_sub <- unique(stats::na.omit(edges_sub))
    
    if (nrow(edges_sub) >= 2) {
      set.seed(42)
      g <- igraph::graph_from_data_frame(edges_sub, directed = FALSE)
      p_net <- ggraph::ggraph(g, layout = "fr") +
        ggraph::geom_edge_link(alpha = 0.4) +
        ggraph::geom_node_point(size = 3) +
        ggraph::geom_node_text(ggplot2::aes(label = name), repel = TRUE, size = 2.8) +
        ggplot2::labs(title = "Predicted miRNA–Gen Bağlantı Ağı (alt küme)") +
        ggplot2::theme_void(base_size = 14)
      
      ggplot2::ggsave(filename = file.path(plot_dir, "predicted_miRNA_gene_network.png"),
                      plot = p_net, width = 10, height = 8, dpi = 300)
      utils::write.csv(edges_sub, file.path(plot_dir, "predicted_network_edges_subset.csv"),
                       row.names = FALSE)
    }
    
    ## ---------- 9) Isı haritası (top-20x20) ----------
    suppressPackageStartupMessages(library(pheatmap))
    tab <- table(mm_net_predicted[[target_col]], mm_net_predicted[[mirna_col]])
    row_sel <- utils::head(names(sort(rowSums(tab), decreasing = TRUE)), min(20, nrow(tab)))
    col_sel <- utils::head(names(sort(colSums(tab), decreasing = TRUE)), min(20, ncol(tab)))
    mat <- as.matrix(tab[row_sel, col_sel, drop = FALSE])
    
    if (nrow(mat) > 1 && ncol(mat) > 1) {
      pheatmap::pheatmap(
        mat,
        cluster_rows = TRUE, cluster_cols = TRUE,
        color = colorRampPalette(c("white","red"))(50),
        main  = "Predicted miRNA–Gen Etkileşim Isı Haritası",
        filename = file.path(plot_dir, "predicted_miRNA_gene_heatmap.png"),
        width = 8, height = 6
      )
    }
  }
}

message(">> Predicted (TargetScan hariç) miRNA–hedef bloğu tamamlandı.")



#DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD

## --- multiMiR ile miRNA hedef verisi çekimi ve sonuç işlemleri ---
## Varsayımlar: 'tt_gene' mevcut ve en azından 'SYMBOL' ve 'adj.P.Val' içeriyor.

# 1) Evren ve anlamlı genler
sig_genes <- unique(tt_gene$SYMBOL[!is.na(tt_gene$SYMBOL) & tt_gene$adj.P.Val < 0.1])

if (length(sig_genes) == 0) {
  message("multiMiR atlandı: adj.P.Val < 0.1 ile anlamlı gen yok.")
  mm_net_df <- NULL
} else {
  # 2) Korumalı wrapper: safe_multimir_table yoksa multiMiR ile çek
  if (!exists("safe_multimir_table")) {
    if (!requireNamespace("multiMiR", quietly = TRUE)) {
      mm_net_df <- NULL
      warning("multiMiR paketi yok; miRNA hedefleri çekilemedi.")
    } else {
      mm <- multiMiR::get_multimir(org="hsa", target=sig_genes,
                                   table="validated", summary=TRUE)
      mm_net_df <- multiMiR::multimir_results(mm)
    }
  } else {
    mm_net_df <- safe_multimir_table(sig_genes, "validated")
  }
  
  # 3) Hedef kolonunu mm_net_df ÜZERİNDEN tespit et
  if (!is.null(mm_net_df)) {
    tgt_candidates <- c("target_symbol","target","target.gene","SYMBOL")
    tgt_col <- intersect(tgt_candidates, names(mm_net_df))[1]
    if (is.na(tgt_col)) {
      warning("Hedef kolonu bulunamadı (target_symbol vb.).")
    } else {
      mm_net_df <- mm_net_df[!is.na(mm_net_df[[tgt_col]]) &
                               nzchar(mm_net_df[[tgt_col]]) &
                               (toupper(mm_net_df[[tgt_col]]) %in% toupper(sig_genes)), ,
                             drop = FALSE]
    }
  }
}


## --- UMAP görselleştirme yardımcıları ---
plot_umap <- function(expr_mat, pheno_vec, n_neighbors = 8, seed = 123) {
  stopifnot(identical(colnames(expr_mat), names(pheno_vec)))
  um <- umap::umap(t(expr_mat), n_neighbors = n_neighbors, random_state = seed)
  df <- data.frame(
    Sample = colnames(expr_mat),
    UMAP1  = um$layout[,1],
    UMAP2  = um$layout[,2],
    Group  = as.factor(pheno_vec)
  )
  ggplot2::ggplot(df, ggplot2::aes(UMAP1, UMAP2, color = Group, label = Sample)) +
    ggplot2::geom_point(size = 2) +
    ggplot2::theme_minimal(base_size = 13) +
    ggplot2::labs(title = "UMAP QC (kanonik ifade)")
}
# Kullanım (kanonik matris ve grup vektörü ile):
# p_umap <- plot_umap(expr_mat, setNames(as.character(ph$group), rownames(ph)))


## ---- SPECIALCASE-BAZLI TASARIM (sıra düzeltilmiş) ----
ph <- pheno_aligned

# 1) specialcase → "No"/"Yes" (MELAS vurgulu)
sc_raw <- tolower(trimws(as.character(ph$specialcase)))
ph$sp  <- factor(ifelse(sc_raw %in% c("1","yes","y","true","melas"), "Yes", "No"),
                 levels = c("No","Yes"))

# 2) Tasarım ve kontroller
DESIGN <- model.matrix(~ 0 + sp, data = ph)
stopifnot(ncol(expr_mat) == nrow(DESIGN))
stopifnot(qr(DESIGN)$rank == ncol(DESIGN))
stopifnot(all(table(ph$sp) > 0))

# 3) Fit + kontrast (Yes - No)
fit_sp  <- limma::lmFit(expr_mat, DESIGN)
cont_sp <- limma::makeContrasts(spYes - spNo, levels = DESIGN)
fit_sp2 <- limma::eBayes(limma::contrasts.fit(fit_sp, cont_sp), robust = TRUE)
tt_sp   <- limma::topTable(fit_sp2, number = Inf, sort.by = "P")

# 4) TREAT: biyolojik eşik (örn. 1.2x ya da 1.5x)
fit_spc    <- limma::contrasts.fit(fit_sp, cont_sp)
fit_sp_tr  <- limma::treat(fit_spc, lfc = log2(1.5))  # 1.5-kat örneği
tt_sp_tr   <- limma::topTable(fit_sp_tr, number = Inf)

## --- MELAS hariç: kanonik matris ve kolon isimleri ---
expr_noM <- expr_mat[, rownames(ph_noM), drop = FALSE]
design_noM <- model.matrix(cov_formula_noM, data = ph_noM)
stopifnot(identical(colnames(expr_noM), rownames(ph_noM)))
stopifnot(qr(design_noM)$rank == ncol(design_noM))

# Kolon adlarını kontrol et; gerekirse ayarla
# colnames(design_noM) örn. "groupControl","groupPompe", "sexM", "age", "batchB2", ...
cont_noM <- limma::makeContrasts(groupPompe - groupControl, levels = design_noM)

fit_noM  <- limma::lmFit(expr_noM, design_noM)
fit_noM2 <- limma::eBayes(limma::contrasts.fit(fit_noM, cont_noM), robust = TRUE)
tt_noM   <- limma::topTable(fit_noM2, number = Inf, sort.by = "P")

# TREAT (opsiyonel)
fitc_noM  <- limma::contrasts.fit(fit_noM, cont_noM)
fit_treat <- limma::treat(fitc_noM, lfc = log2(1.5))
tt_treat  <- limma::topTable(fit_treat, number = Inf)




#EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
## =========================
## D BLOĞU: İlaç/Hedef & Ağ
## =========================

## 0) Paketler (sessiz yükle)
suppressPackageStartupMessages({
  library(AnnotationDbi)
  library(hgu133plus2.db)
  library(org.Hs.eg.db)
  library(dplyr); library(stringr); library(tibble)
  library(clusterProfiler)
})
# İnternet gerektirenler isteğe bağlı
RUN_DGIDB  <- TRUE
RUN_STRING <- TRUE
RUN_GDSC   <- FALSE  # keşif amaçlı, default kapalı

if (RUN_DGIDB) {
  if (!requireNamespace("rDGIdb", quietly = TRUE)) {
    warning("rDGIdb yok; RUN_DGIDB=FALSE yapılıyor."); RUN_DGIDB <- FALSE
  } else library(rDGIdb)
}
if (RUN_STRING) {
  if (!requireNamespace("STRINGdb", quietly = TRUE) ||
      !requireNamespace("igraph",   quietly = TRUE)) {
    warning("STRINGdb/igraph yok; RUN_STRING=FALSE yapılıyor."); RUN_STRING <- FALSE
  } else { library(STRINGdb); library(igraph) }
}
if (RUN_GDSC) {
  if (!requireNamespace("PharmacoGx", quietly = TRUE) ||
      !requireNamespace("curl",        quietly = TRUE)) {
    warning("PharmacoGx/curl yok; RUN_GDSC=FALSE yapılıyor."); RUN_GDSC <- FALSE
  } else { library(PharmacoGx); library(curl) }
}

## 1) Kanonik ifade matrisi & pheno kontrol (C bloğundan gelmeli)
stopifnot(exists("expr_mat"), exists("pheno_aligned"))
stopifnot(identical(colnames(expr_mat), rownames(pheno_aligned)))

## 2) (İsteğe bağlı) no-MELAS dalında fit_noM$genes doldur
if (exists("fit_noM") && exists("cont_noM")) {
  # lmFit hemen sonrasına konmalı (burada da güvenli tekrar dolduruyoruz)
  probe_ids <- rownames(expr_mat)  # PROBEID olduğunu varsayar
  probe2sym <- AnnotationDbi::mapIds(hgu133plus2.db, keys = probe_ids,
                                     column = "SYMBOL",  keytype = "PROBEID", multiVals = "first")
  probe2ent <- AnnotationDbi::mapIds(hgu133plus2.db, keys = probe_ids,
                                     column = "ENTREZID", keytype = "PROBEID", multiVals = "first")
  fit_noM$genes <- data.frame(PROBEID = probe_ids,
                              SYMBOL  = unname(probe2sym),
                              ENTREZID= unname(probe2ent))
  # kontrast + eBayes (robust önerilir)
  fit_noM2 <- limma::eBayes(limma::contrasts.fit(fit_noM, cont_noM), robust = TRUE)
}

## 3) Çalışılacak DEG tablosunu seç (treat > noM > tt)
if (exists("tt_treat")) {
  tt_base <- tt_treat
} else if (exists("tt_noM")) {
  tt_base <- tt_noM
} else if (exists("tt")) {
  tt_base <- tt
} else {
  stop("DEG tablosu bulunamadı (tt_treat / tt_noM / tt).")
}
stopifnot(nrow(tt_base) > 0)

## 4) Eğer SYMBOL yoksa sonradan anotasyonla ekle
if (!"SYMBOL" %in% colnames(tt_base)) {
  tt_base$PROBEID <- rownames(tt_base)
  ann <- AnnotationDbi::select(hgu133plus2.db,
                               keys = tt_base$PROBEID,
                               columns = c("SYMBOL","ENTREZID"),
                               keytype = "PROBEID") |>
    distinct(PROBEID, .keep_all = TRUE)
  tt_base <- tt_base |>
    left_join(ann, by = "PROBEID")
}

## 5) Gen düzeyine indirgeme (en küçük adj.P.Val veya en büyük |t|)
tt_gene <- tt_base |>
  filter(!is.na(SYMBOL), nzchar(SYMBOL)) |>
  group_by(SYMBOL) |>
  slice_min(order_by = adj.P.Val, n = 1, with_ties = FALSE) |>
  ungroup()

bg_genes  <- unique(tt_gene$SYMBOL)
sig_genes <- unique(tt_gene$SYMBOL[tt_gene$adj.P.Val < 0.05])

if (length(sig_genes) == 0) {
  warning("adj.P.Val < 0.05 ile anlamlı gen yok; D bloğu atlanıyor.")
} else {
  
  ## 6) DGIdb: Drug–Gene zenginleştirme (opsiyonel)
  if (RUN_DGIDB) {
    dg <- tryCatch(rDGIdb::queryDGIdb(genes = sig_genes),
                   error = function(e) { warning("DGIdb hatası: ", e$message); NULL })
    if (!is.null(dg) && length(dg@interactions) > 0) {
      dg_df <- as.data.frame(dg@interactions, stringsAsFactors = FALSE)
      if (nrow(dg_df) > 0) {
        # TERM2GENE (drug→gene)
        drug_t2g <- dg_df |>
          transmute(term = toupper(str_replace_all(drugName, "_", " ")),
                    gene = geneName) |>
          distinct()
        # evren: bg_genes
        enr <- clusterProfiler::enricher(
          gene         = sig_genes,
          TERM2GENE    = drug_t2g,
          universe     = bg_genes,
          pAdjustMethod= "BH"
        )
        dg_best <- if (!is.null(enr)) {
          as.data.frame(enr) |>
            mutate(drug = toupper(str_replace_all(ID, "_", " "))) |>
            arrange(p.adjust) |>
            group_by(drug) |>
            slice_min(order_by = p.adjust, n = 1, with_ties = FALSE) |>
            ungroup()
        } else NULL
        message(">> DGIdb zenginleştirme tamam. N=",
                ifelse(is.null(dg_best), 0L, nrow(dg_best)))
      } else message("DGIdb: etkileşim gelmedi.")
    } else message("DGIdb: sonuç yok ya da sorgu başarısız.")
  }
  
  ## 7) STRINGdb: PPI alt-ağı (opsiyonel)
  if (RUN_STRING) {
    string_db <- STRINGdb$new(version = "11.5", species = 9606,
                              score_threshold = 400, input_directory = "")
    map_df <- data.frame(gene = sig_genes, stringsAsFactors = FALSE)
    map_df <- tryCatch(string_db$map(map_df, "gene", removeUnmappedRows = TRUE),
                       error = function(e) { warning("STRING map hatası: ", e$message); NULL })
    if (!is.null(map_df) && nrow(map_df) > 0) {
      ids <- unique(map_df$STRING_id)
      ppi_edges <- tryCatch(string_db$get_interactions(ids),
                            error = function(e) { warning("STRING edges hatası: ", e$message); NULL })
      if (!is.null(ppi_edges) && nrow(ppi_edges) > 0) {
        ppi_edges <- ppi_edges |>
          dplyr::filter(from %in% ids & to %in% ids) |>
          distinct(from, to, .keep_all = TRUE)
        if (nrow(ppi_edges) > 0) {
          g2 <- graph_from_data_frame(ppi_edges[, c("from","to")], directed = FALSE)
          E(g2)$weight <- ppi_edges$combined_score
          message(">> STRING PPI ağı: V=", gorder(g2), "  E=", gsize(g2))
          # (istenirse burada ggraph çizimi eklenebilir)
        } else message("STRING: filtre sonrası kenar kalmadı.")
      } else message("STRING: etkileşim bulunamadı.")
    } else message("STRING: haritalanan gen yok.")
  }
  
  ## 8) (Opsiyonel) PharmacoGx / GDSC
  if (RUN_GDSC) {
    ok_net <- tryCatch(curl::has_internet(), error = function(e) FALSE)
    if (!ok_net) {
      warning("İnternet yok: GDSC atlandı.")
    } else {
      # cache
      cache_dir <- tools::R_user_dir("PharmacoGx", which = "data")
      dir.create(cache_dir, recursive = TRUE, showWarnings = FALSE)
      avail <- tryCatch(PharmacoGx::availablePSets(), error = function(e) character())
      try_download <- function(name) tryCatch(
        PharmacoGx::downloadPSet(name, saveDir = cache_dir),
        error = function(e) { message("PSet hata: ", conditionMessage(e)); NULL }
      )
      GDSC <- NULL
      for (nm in c("GDSC","GDSC2")) {
        if (nm %in% avail || length(avail) == 0) { GDSC <- try_download(nm); if (!is.null(GDSC)) break }
      }
      if (is.null(GDSC)) {
        warning("GDSC/GDSC2 indirilemedi.")
      } else {
        sensitivityInfo     <- PharmacoGx::sensitivityInfo(GDSC)
        sensitivityProfiles <- PharmacoGx::sensitivityProfiles(GDSC)
        drug                <- PharmacoGx::drugInfo(GDSC)
        cell                <- PharmacoGx::cellInfo(GDSC)
        message(">> PharmacoGx hazır: ", nrow(sensitivityInfo), " ölçüm.")
      }
    }
  }
}

## 9) Kısa rapor
cat("D bloğu tamamlandı.\n",
    "BG gen sayısı:", length(bg_genes), " | SIG gen sayısı:", length(sig_genes), "\n")


#FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
## =====================================================================
## CLEAN PATHWAY BLOCK  —  limma → DEG → GSEA (Hallmark/KEGG) + ORA (GO/KEGG)
## =====================================================================

suppressPackageStartupMessages({
  library(limma)
  library(AnnotationDbi)
  library(hgu133plus2.db)
  library(org.Hs.eg.db)
  library(clusterProfiler)
  library(msigdbr)
  library(enrichplot)
  library(ggplot2)
  library(pheatmap)
  library(dplyr)
  library(stringr)
})

## ---- 0) Eşikler & klasörler --------------------------------------------------
FDR_THRESH   <- get0("FDR_THRESH",   ifnotfound = 0.05)
LOGFC_THRESH <- get0("LOGFC_THRESH", ifnotfound = 1.0)
out_dir  <- get0("out_dir",  ifnotfound = file.path(getwd(), "results", "deg"))
plot_dir <- get0("plot_dir", ifnotfound = file.path(getwd(), "results", "plots"))
dir.create(out_dir,  recursive = TRUE, showWarnings = FALSE)
dir.create(plot_dir, recursive = TRUE, showWarnings = FALSE)

save_png <- function(p, fname, w=8, h=6, dpi=300) {
  ggplot2::ggsave(filename = file.path(plot_dir, fname), plot = p, width = w, height = h, dpi = dpi)
}

## ---- 1) Girdi kontrolleri ----------------------------------------------------
stopifnot(exists("expr_mat"), is.matrix(expr_mat), ncol(expr_mat) > 1)
stopifnot(exists("pheno_aligned"), nrow(pheno_aligned) == ncol(expr_mat))
stopifnot("group" %in% names(pheno_aligned))

## ---- 2) Design/kontrast yoksa oluştur ---------------------------------------
if (!exists("design")) {
  pheno_aligned$group <- factor(pheno_aligned$group, levels = c("Control","Pompe"))
  design <- model.matrix(~ 0 + group, data = pheno_aligned)
  colnames(design) <- levels(pheno_aligned$group)
}
stopifnot(ncol(expr_mat) == nrow(design))
if (!exists("cont")) {
  cont <- limma::makeContrasts(PompeVsControl = Pompe - Control, levels = design)
}

## ---- 3) limma fit → tt_all / gene-level özet --------------------------------
fit  <- limma::lmFit(expr_mat, design)
fit2 <- limma::eBayes(limma::contrasts.fit(fit, cont), robust = TRUE)
tt_all <- limma::topTable(fit2, coef = 1, number = Inf, adjust.method = "BH")  # rows = PROBEID
tt_all$PROBEID <- rownames(tt_all)

## 3a) PROBEID → SYMBOL/ENTREZ ekle (gene-level tekilleştirme için)
ann <- AnnotationDbi::select(hgu133plus2.db,
                             keys    = tt_all$PROBEID,
                             keytype = "PROBEID",
                             columns = c("SYMBOL","ENTREZID")) |>
  distinct(PROBEID, .keep_all = TRUE)
tt_all <- tt_all |> left_join(ann, by = "PROBEID")

## 3b) Gene-level tablo (her SYMBOL için en iyi satır: min adj.P, eşitlikte |t| büyük)
tt_all$abs_t <- abs(tt_all$t)
tt_sym <- tt_all |>
  filter(!is.na(SYMBOL), nzchar(SYMBOL)) |>
  arrange(SYMBOL, adj.P.Val, desc(abs_t)) |>
  group_by(SYMBOL) |>
  slice(1) |>
  ungroup()

## 3c) DEG seti (rapor)
deg <- subset(tt_sym, adj.P.Val < FDR_THRESH & abs(logFC) >= LOGFC_THRESH)
write.csv(tt_all, file.path(out_dir, "limma_all_probes.csv"), row.names = FALSE)
write.csv(tt_sym, file.path(out_dir, "limma_gene_level.csv"), row.names = FALSE)
write.csv(deg,    file.path(out_dir, sprintf("DEG_FDR_lt_%g_logFC_ge_%g.csv", FDR_THRESH, LOGFC_THRESH)), row.names = FALSE)

## ---- 4) Volcano (ana karşılaştırma) ------------------------------------------
volc_df <- transform(
  tt_sym,
  negLog10FDR = -log10(pmax(adj.P.Val, .Machine$double.eps)),
  dir = ifelse(adj.P.Val < FDR_THRESH & logFC >  LOGFC_THRESH, "Up",
               ifelse(adj.P.Val < FDR_THRESH & logFC < -LOGFC_THRESH, "Down","NS"))
)
p_volc <- ggplot(volc_df, aes(x = logFC, y = negLog10FDR, color = dir)) +
  geom_hline(yintercept = -log10(FDR_THRESH), linetype = 2) +
  geom_vline(xintercept = c(-LOGFC_THRESH, LOGFC_THRESH), linetype = 3) +
  geom_point(size = 1.2, alpha = .7) +
  scale_color_manual(values = c(Down="#377EB8", Up="#E41A1C", NS="grey70")) +
  labs(title = "Volcano — Pompe vs Control", x = "log2FC", y = "-log10(FDR)") +
  theme_minimal(base_size = 12)
save_png(p_volc, "volcano_main.png", w=8, h=6)

## ---- 5) Heatmap (Top-N DEG, gene-level) --------------------------------------
TOP_N <- get0("TOP_N", ifnotfound = 50)
top_syms <- head(deg$SYMBOL[order(deg$adj.P.Val)], min(TOP_N, nrow(deg)))

## Probe→gene indirgeme (IQR’e göre en değişken probeyi seç)
probe_map <- AnnotationDbi::select(hgu133plus2.db,
                                   keys    = rownames(expr_mat),
                                   keytype = "PROBEID",
                                   columns = "SYMBOL") |>
  distinct(PROBEID, .keep_all = TRUE)
sym_of_probe <- probe_map$SYMBOL[match(rownames(expr_mat), probe_map$PROBEID)]
keep_rows <- !is.na(sym_of_probe) & nzchar(sym_of_probe)
expr_sym  <- expr_mat[keep_rows, , drop = FALSE]
sym_vec   <- toupper(sym_of_probe[keep_rows])
rownames(expr_sym) <- make.unique(sym_vec)

iqr_probe <- apply(expr_sym, 1, IQR, na.rm = TRUE)
best_idx  <- tapply(seq_along(sym_vec), sym_vec, function(ii) ii[which.max(iqr_probe[ii])])
expr_gene <- expr_sym[unlist(best_idx), , drop = FALSE]
rownames(expr_gene) <- names(best_idx)

hm_genes <- intersect(rownames(expr_gene), toupper(top_syms))
if (length(hm_genes) >= 2) {
  sub_expr   <- expr_gene[hm_genes, , drop = FALSE]
  sub_expr_z <- t(scale(t(sub_expr)))
  pheatmap::pheatmap(
    sub_expr_z, show_rownames = TRUE, show_colnames = FALSE,
    annotation_col = data.frame(Group = pheno_aligned$group,
                                row.names = rownames(pheno_aligned)),
    main = sprintf("Top %d DEG (z-scored, gene-level)", length(hm_genes)),
    filename = file.path(plot_dir, sprintf("heatmap_top%d_deg.png", length(hm_genes))),
    width = 8, height = 10
  )
}

## ---- 6) GSEA — Hallmark (SYMBOL) --------------------------------------------
## Ranks: SYMBOL adlarıyla imzalı, t-istatistiği tercih (yoksa logFC)
ranks_tbl <- tt_sym |>
  transmute(SYMBOL = toupper(SYMBOL),
            score  = ifelse(is.finite(t), t, logFC)) |>
  filter(!is.na(score), is.finite(score))
## Aynı gen için tek değer: |score| en büyük olanı
ranks_vec <- tapply(ranks_tbl$score, ranks_tbl$SYMBOL,
                    function(x) x[which.max(abs(x))])
ranks_vec <- sort(as.numeric(ranks_vec), decreasing = TRUE)
names(ranks_vec) <- names(tapply(ranks_tbl$score, ranks_tbl$SYMBOL, c))
stopifnot(length(ranks_vec) > 0)

## Hallmark TERM2GENE
term2gene_H <- msigdbr(species = "Homo sapiens", category = "H") |>
  transmute(term = gs_name, gene = toupper(gene_symbol)) |>
  distinct()

common_H <- intersect(names(ranks_vec), term2gene_H$gene)
gsea_h <- GSEA(geneList  = ranks_vec[common_H],
               TERM2GENE = term2gene_H[term2gene_H$gene %in% common_H, ],
               verbose = FALSE)

## Görselleştirme — Hallmark
if (!is.null(gsea_h) && nrow(as.data.frame(gsea_h)) > 0) {
  p_h_dot <- enrichplot::dotplot(gsea_h, showCategory = 20)
  save_png(p_h_dot, "gsea_hallmark_dotplot.png", w=8, h=6)
  top_id <- gsea_h@result$ID[1]
  p_h_gs <- enrichplot::gseaplot2(gsea_h, geneSetID = top_id, title = paste("Hallmark:", top_id))
  save_png(p_h_gs, "gsea_hallmark_gseaplot2_top.png", w=9, h=6)
  write.csv(as.data.frame(gsea_h), file.path(out_dir, "GSEA_Hallmark.csv"), row.names = FALSE)
}

## ---- 7) GSEA — KEGG (ENTREZ) -------------------------------------------------
## SYMBOL → ENTREZ map
map_sym_to_entrez <- function(sym) {
  df <- AnnotationDbi::select(org.Hs.eg.db, keys = unique(sym),
                              keytype = "SYMBOL", columns = "ENTREZID")
  df <- df[!is.na(df$ENTREZID) & nzchar(df$ENTREZID), ]
  distinct(df, SYMBOL, ENTREZID)
}
eg <- map_sym_to_entrez(names(ranks_vec))
geneList <- ranks_vec[eg$SYMBOL]
names(geneList) <- eg$ENTREZID
## Aynı ENTREZ tekrarı → |değer| en büyük kalsın
geneList <- tapply(geneList, names(geneList), function(x) x[which.max(abs(x))])
geneList <- sort(as.numeric(geneList), decreasing = TRUE)
names(geneList) <- names(tapply(geneList, names(geneList), c))

gsea_kegg <- try(
  clusterProfiler::gseKEGG(
    geneList     = geneList,
    organism     = "hsa",
    keyType      = "ncbi-geneid",
    minGSSize    = 10,
    pvalueCutoff = 1,
    verbose      = FALSE
  ),
  silent = TRUE
)

if (!inherits(gsea_kegg, "try-error") && !is.null(gsea_kegg) &&
    nrow(as.data.frame(gsea_kegg)) > 0) {
  p_k_dot <- enrichplot::dotplot(gsea_kegg, showCategory = 20)
  save_png(p_k_dot, "gsea_kegg_dotplot.png", w=8, h=6)
  top_id <- gsea_kegg@result$ID[1]
  p_k_gs <- enrichplot::gseaplot2(gsea_kegg, geneSetID = top_id, title = paste("KEGG:", top_id))
  save_png(p_k_gs, "gsea_kegg_gseaplot2_top.png", w=9, h=6)
  write.csv(as.data.frame(gsea_kegg), file.path(out_dir, "GSEA_KEGG.csv"), row.names = FALSE)
} else {
  message("KEGG GSEA sonucu bulunamadı (kesişim az olabilir).")
}

## ---- 8) ORA — GO:BP (SYMBOL) & KEGG (ENTREZ) ---------------------------------
sig_symbols <- unique(tt_sym$SYMBOL[tt_sym$adj.P.Val < FDR_THRESH])
bg_symbols  <- unique(tt_sym$SYMBOL)

if (length(sig_symbols) > 0) {
  go_bp <- clusterProfiler::enrichGO(
    gene          = sig_symbols,
    universe      = bg_symbols,
    OrgDb         = org.Hs.eg.db,
    keyType       = "SYMBOL",
    ont           = "BP",
    pAdjustMethod = "BH"
  )
  if (!is.null(go_bp) && nrow(as.data.frame(go_bp)) > 0) {
    p_go <- enrichplot::dotplot(go_bp, showCategory = 20)
    save_png(p_go, "ORA_GO_BP_dotplot.png", w=8, h=6)
    write.csv(as.data.frame(go_bp), file.path(out_dir, "ORA_GO_BP.csv"), row.names = FALSE)
  }
}

## KEGG ORA (ENTREZ)
eg_bg  <- map_sym_to_entrez(bg_symbols)
eg_sig <- map_sym_to_entrez(sig_symbols)
entrez_universe <- unique(eg_bg$ENTREZID)
entrez_sig      <- unique(eg_sig$ENTREZID)

if (length(entrez_sig) > 0) {
  ek_args <- list(gene = entrez_sig, organism = "hsa",
                  universe = entrez_universe, pAdjustMethod = "BH")
  if ("keyType" %in% names(formals(clusterProfiler::enrichKEGG)))
    ek_args$keyType <- "ncbi-geneid"
  kegg_ora <- do.call(clusterProfiler::enrichKEGG, ek_args)
  if (!is.null(kegg_ora) && nrow(as.data.frame(kegg_ora)) > 0) {
    p_kegg <- enrichplot::dotplot(kegg_ora, showCategory = 20)
    save_png(p_kegg, "ORA_KEGG_dotplot.png", w=8, h=6)
    write.csv(as.data.frame(kegg_ora), file.path(out_dir, "ORA_KEGG.csv"), row.names = FALSE)
  }
}

## ---- 9) Kısa özet ------------------------------------------------------------
message(sprintf("DEGs: up=%d, down=%d (FDR<%.3g, |logFC|≥%.2f)",
                sum(deg$logFC > 0, na.rm=TRUE), sum(deg$logFC < 0, na.rm=TRUE),
                FDR_THRESH, LOGFC_THRESH))
message(sprintf("GSEA Hallmark: %d set; KEGG GSEA: %s",
                ifelse(exists("gsea_h"), nrow(as.data.frame(gsea_h)), 0L),
                ifelse(exists("gsea_kegg") && !inherits(gsea_kegg,"try-error"),
                       nrow(as.data.frame(gsea_kegg)), 0L)))
message("Pathway bloğu tamamlandı: CSV ve PNG dosyalarını 'out_dir' ve 'plot_dir' altında bulabilirsiniz.")


#GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG



# ============================================================
# POMPE "HEMEN KULLAN" FİGÜR PANELİ
# Fig2: Boxplot + PCA + UMAP + Heatmap + Volcano
# Fig3: GO/KEGG ORA + Hallmark GSEA + BioCarta ssGSEA
# Fig4A–D: STRING PPI + hub çubuk grafikleri
# Fig4F: multiMiR (validated) ağ + özet barplotlar
# Fig6: ssGSEA skorlarıyla (Hallmark/BioCarta) örnek ayrışması (PCA/UMAP)
# ============================================================

suppressPackageStartupMessages({
  library(ggplot2); library(pheatmap); library(dplyr); library(tidyr)
  library(limma); library(AnnotationDbi); library(hgu133plus2.db); library(org.Hs.eg.db)
  library(clusterProfiler); library(enrichplot); library(msigdbr); library(GSVA); library(umap)
})

# --- klasör/yardımcılar ---
plot_dir <- get0("plot_dir", ifnotfound = file.path(getwd(), "results", "plots"))
out_dir  <- get0("out_dir",  ifnotfound = file.path(getwd(), "results", "deg"))
dir.create(plot_dir, recursive = TRUE, showWarnings = FALSE)
dir.create(out_dir,  recursive = TRUE, showWarnings = FALSE)
save_png <- function(p, name, w=8, h=6, dpi=300) {
  ggplot2::ggsave(file.path(plot_dir, name), p, width = w, height = h, dpi = dpi)
}

# --- 0) GENE-LEVEL ifade matrisi (rownames = SYMBOL, tekilleştirilmiş) ---
make_gene_level_matrix <- function(expr_mat) {
  probe_map <- AnnotationDbi::select(hgu133plus2.db,
                                     keys    = rownames(expr_mat),
                                     keytype = "PROBEID",
                                     columns = "SYMBOL") |>
    distinct(PROBEID, .keep_all = TRUE)
  sym_of_probe <- probe_map$SYMBOL[match(rownames(expr_mat), probe_map$PROBEID)]
  keep <- !is.na(sym_of_probe) & nzchar(sym_of_probe)
  ex  <- expr_mat[keep, , drop = FALSE]
  sy  <- toupper(sym_of_probe[keep])
  rownames(ex) <- make.unique(sy)
  
  iqr_by_row <- apply(ex, 1, IQR, na.rm = TRUE)
  pick <- tapply(seq_along(sy), sy, function(ix) ix[which.max(iqr_by_row[ix])])
  ex_gene <- ex[unlist(pick), , drop = FALSE]
  rownames(ex_gene) <- names(pick)
  ex_gene
}

stopifnot(exists("expr_mat"), exists("pheno_aligned"))
expr_gene <- make_gene_level_matrix(expr_mat)
groups    <- droplevels(pheno_aligned$group)
names(groups) <- rownames(pheno_aligned)

# --- 1) LIMMA sonuçları yoksa üret (tt_sym, deg, p_volc) ---
FDR_THRESH   <- get0("FDR_THRESH",   ifnotfound = 0.05)
LOGFC_THRESH <- get0("LOGFC_THRESH", ifnotfound = 1.0)

if (!exists("tt_sym") || !exists("deg")) {
  design <- model.matrix(~0 + group, data = pheno_aligned)
  colnames(design) <- levels(pheno_aligned$group)
  fit  <- lmFit(expr_mat, design)
  cont <- makeContrasts(PompeVsControl = Pompe - Control, levels = design)
  fit2 <- eBayes(contrasts.fit(fit, cont), robust = TRUE)
  tt_all <- topTable(fit2, number = Inf, sort.by = "P")
  tt_all$PROBEID <- rownames(tt_all)
  ann <- AnnotationDbi::select(hgu133plus2.db,
                               keys=tt_all$PROBEID, keytype="PROBEID",
                               columns=c("SYMBOL","ENTREZID")) |>
    distinct(PROBEID, .keep_all = TRUE)
  tt_all <- left_join(tt_all, ann, by="PROBEID")
  tt_all$abs_t <- abs(tt_all$t)
  tt_sym <- tt_all |>
    filter(!is.na(SYMBOL), nzchar(SYMBOL)) |>
    arrange(SYMBOL, adj.P.Val, desc(abs_t)) |>
    group_by(SYMBOL) |> slice(1) |> ungroup()
  deg <- subset(tt_sym, adj.P.Val < FDR_THRESH & abs(logFC) >= LOGFC_THRESH)
}

# ============================================================
# FIGÜR 2 PANELİ
# ============================================================

# (a) Boxplot — örnek başına log2 ifade dağılımı
{
  bp_df <- data.frame(
    Sample = rep(colnames(expr_mat), each = nrow(expr_mat)),
    Value  = as.vector(expr_mat)
  )
  bp_df$Group <- groups[match(bp_df$Sample, names(groups))]
  p_box <- ggplot(bp_df, aes(x = Sample, y = Value, fill = Group)) +
    geom_boxplot(outlier.size = 0.2, linewidth=.2) +
    labs(title="Dağılım kutu grafiği — RMA (log2)", x=NULL, y="İfade (log2)") +
    theme_minimal(base_size = 11) + theme(axis.text.x = element_text(angle = 90, vjust=.5,hjust=1))
  save_png(p_box, "fig2a_boxplot_rma.png", w=10, h=5)
}

# (b) PCA
{
  pc <- prcomp(t(expr_mat), scale. = TRUE)
  pca_df <- data.frame(PC1 = pc$x[,1], PC2 = pc$x[,2],
                       Group = groups, Sample = rownames(pheno_aligned))
  p_pca <- ggplot(pca_df, aes(PC1, PC2, color=Group, label=Sample)) +
    geom_point(size=2) + theme_bw(base_size=12) +
    labs(title="PCA — Pompe vs Control") +
    ggrepel::geom_text_repel(size=2.8, max.overlaps = 20, show.legend = FALSE)
  save_png(p_pca, "fig2b_pca.png", w=7.5, h=6)
}

# (c) UMAP
{
  um <- umap::umap(t(expr_mat), n_neighbors = 8, random_state = 123)
  um_df <- data.frame(UMAP1 = um$layout[,1], UMAP2 = um$layout[,2],
                      Group = groups, Sample = rownames(pheno_aligned))
  p_umap <- ggplot(um_df, aes(UMAP1, UMAP2, color=Group, label=Sample)) +
    geom_point(size=2) + theme_minimal(base_size=12) +
    labs(title="UMAP — Pompe vs Control") +
    ggrepel::geom_text_repel(size=2.8, max.overlaps = 20, show.legend = FALSE)
  save_png(p_umap, "fig2c_umap.png", w=7.5, h=6)
}

# (d) Heatmap — Top-N DEG (gene-level)
{
  TOP_N <- get0("TOP_N", ifnotfound = 50)
  top_syms <- head(deg$SYMBOL[order(deg$adj.P.Val)], min(TOP_N, nrow(deg)))
  hm_genes <- intersect(rownames(expr_gene), toupper(top_syms))
  if (length(hm_genes) >= 2) {
    z <- t(scale(t(expr_gene[hm_genes,,drop=FALSE])))
    ann <- data.frame(Group = groups, row.names = names(groups))
    pheatmap::pheatmap(z, annotation_col = ann, show_colnames = FALSE,
                       main = sprintf("Top %d DEG (z-score)", length(hm_genes)),
                       filename = file.path(plot_dir, "fig2d_heatmap_topdeg.png"),
                       width = 8, height = 10)
  }
}

# (e) Volcano
{
  volc_df <- transform(
    tt_sym,
    negLog10FDR = -log10(pmax(adj.P.Val, .Machine$double.eps)),
    dir = ifelse(adj.P.Val < FDR_THRESH & logFC >  LOGFC_THRESH, "Up",
                 ifelse(adj.P.Val < FDR_THRESH & logFC < -LOGFC_THRESH, "Down","NS"))
  )
  p_volc <- ggplot(volc_df, aes(logFC, negLog10FDR, color=dir)) +
    geom_hline(yintercept = -log10(FDR_THRESH), linetype=2) +
    geom_vline(xintercept = c(-LOGFC_THRESH, LOGFC_THRESH), linetype=3) +
    geom_point(size=1.2, alpha=.75) +
    scale_color_manual(values=c(Down="#377EB8", Up="#E41A1C", NS="grey70")) +
    labs(title="Volcano — Pompe vs Control", x="log2FC", y="-log10(FDR)") +
    theme_minimal(base_size=12)
  save_png(p_volc, "fig2e_volcano.png", w=8, h=6)
}

# ============================================================
# FIGÜR 3 — Zenginleştirme: GO (BP/MF/CC), KEGG ORA,
# Hallmark GSEA ve BioCarta ssGSEA (örnek bazlı)
# ============================================================

# --- GO ORA (SYMBOL) ---
{
  sig_symbols <- unique(tt_sym$SYMBOL[tt_sym$adj.P.Val < FDR_THRESH])
  bg_symbols  <- unique(tt_sym$SYMBOL)
  if (length(sig_symbols) > 0) {
    for (ont in c("BP","MF","CC")) {
      go_res <- enrichGO(gene = sig_symbols, universe = bg_symbols,
                         OrgDb = org.Hs.eg.db, keyType = "SYMBOL",
                         ont = ont, pAdjustMethod = "BH")
      if (!is.null(go_res) && nrow(as.data.frame(go_res))>0) {
        p_go <- enrichplot::dotplot(go_res, showCategory = 20) + ggtitle(paste0("GO:", ont))
        save_png(p_go, paste0("fig3_go_", tolower(ont), "_dot.png"))
        write.csv(as.data.frame(go_res), file.path(out_dir, paste0("ORA_GO_", ont, ".csv")), row.names = FALSE)
      }
    }
  }
}

# --- KEGG ORA (ENTREZ) ---
map_sym_to_entrez <- function(sym) {
  df <- AnnotationDbi::select(org.Hs.eg.db, keys = unique(sym), keytype = "SYMBOL", columns = "ENTREZID")
  df <- df[!is.na(df$ENTREZID) & nzchar(df$ENTREZID), ]
  distinct(df, SYMBOL, ENTREZID)
}
{
  eg_bg  <- map_sym_to_entrez(unique(tt_sym$SYMBOL))
  eg_sig <- map_sym_to_entrez(unique(tt_sym$SYMBOL[tt_sym$adj.P.Val < FDR_THRESH]))
  if (nrow(eg_sig)>0) {
    ek <- try(enrichKEGG(gene = unique(eg_sig$ENTREZID),
                         universe = unique(eg_bg$ENTREZID),
                         organism = "hsa", keyType="ncbi-geneid",
                         pAdjustMethod = "BH"), silent = TRUE)
    if (!inherits(ek,"try-error") && nrow(as.data.frame(ek))>0) {
      p_kegg <- enrichplot::dotplot(ek, showCategory = 20) + ggtitle("KEGG ORA")
      save_png(p_kegg, "fig3_kegg_ora_dot.png")
      write.csv(as.data.frame(ek), file.path(out_dir,"ORA_KEGG.csv"), row.names = FALSE)
    }
  }
}

# --- Hallmark GSEA (rank = t) ---
{
  ranks_tbl <- tt_sym |> transmute(SYMBOL = toupper(SYMBOL),
                                   score  = ifelse(is.finite(t), t, logFC)) |>
    filter(!is.na(score), is.finite(score))
  ranks_vec <- tapply(ranks_tbl$score, ranks_tbl$SYMBOL, function(x) x[which.max(abs(x))])
  ranks_vec <- sort(as.numeric(ranks_vec), decreasing = TRUE)
  names(ranks_vec) <- names(tapply(ranks_tbl$score, ranks_tbl$SYMBOL, c))
  
  term2gene_H <- msigdbr(species="Homo sapiens", collection = "H") |>
    transmute(term = gs_name, gene = toupper(gene_symbol)) |> distinct()
  common_H <- intersect(names(ranks_vec), term2gene_H$gene)
  gsea_h <- GSEA(geneList = ranks_vec[common_H],
                 TERM2GENE = term2gene_H[term2gene_H$gene %in% common_H,], verbose = FALSE)
  if (!is.null(gsea_h) && nrow(as.data.frame(gsea_h))>0) {
    save_png(enrichplot::dotplot(gsea_h, showCategory = 20) + ggtitle("Hallmark GSEA"),
             "fig3_hallmark_gsea_dot.png")
    top_id <- gsea_h@result$ID[1]
    save_png(enrichplot::gseaplot2(gsea_h, geneSetID = top_id, title = paste("Hallmark:", top_id)),
             "fig3_hallmark_gseaplot2_top.png", w=9, h=6)
    write.csv(as.data.frame(gsea_h), file.path(out_dir, "GSEA_Hallmark.csv"), row.names = FALSE)
  }
}

# --- BioCarta ssGSEA (örnek-bazlı) + ısı haritası ---
{
  bc_t2g <- msigdbr(species="Homo sapiens", collection = "C2", collection = "CP:BIOCARTA") |>
    transmute(term = gs_name, gene = toupper(gene_symbol)) |> split(.$gene, .$term)
  # GSVA ssGSEA: gene-level (SYMBOL) gerektirir
  eset <- as.matrix(expr_gene)
  ssg <- GSVA::gsva(eset, bc_t2g, method = "ssgsea", ssgsea.norm = TRUE, verbose = FALSE)
  # Grup farkları için en çok ayrıştıran 20 yol (t-testi ile kaba seçim)
  grp <- groups[colnames(ssg)]
  delta <- apply(ssg, 1, function(x) {
    g1 <- x[grp=="Control"]; g2 <- x[grp=="Pompe"]
    if (length(g1)>1 && length(g2)>1) mean(g2) - mean(g1) else NA
  })
  top_sets <- names(sort(abs(delta), decreasing = TRUE))[seq_len(min(20, sum(is.finite(delta))))]
  ann <- data.frame(Group = grp, row.names = names(grp))
  pheatmap::pheatmap(ssg[top_sets,,drop=FALSE],
                     annotation_col = ann, show_colnames = FALSE,
                     main = "BioCarta ssGSEA — En farklı 20 yol",
                     filename = file.path(plot_dir, "fig3_biocarta_ssgsea_heatmap.png"),
                     width = 9, height = 8)
  write.csv(ssg, file.path(out_dir, "ssGSEA_BioCarta_scores.csv"))
}

# ============================================================
# FIGÜR 4A–D — STRING PPI & Hub
# ============================================================
RUN_STRING <- TRUE
if (RUN_STRING) {
  ok <- requireNamespace("STRINGdb", quietly = TRUE) && requireNamespace("igraph", quietly = TRUE) && requireNamespace("ggraph", quietly = TRUE)
  if (!ok) { warning("STRINGdb/igraph/ggraph bulunamadı; PPI figürü atlandı.") } else {
    library(STRINGdb); library(igraph); library(ggraph)
    sig_genes <- unique(tt_sym$SYMBOL[tt_sym$adj.P.Val < FDR_THRESH])
    if (length(sig_genes) >= 5) {
      string_db <- STRINGdb$new(version = "11.5", species = 9606, score_threshold = 400, input_directory = "")
      mp <- try(string_db$map(data.frame(gene=sig_genes), "gene", removeUnmappedRows = TRUE), silent = TRUE)
      if (!inherits(mp,"try-error") && nrow(mp)>0) {
        ids <- unique(mp$STRING_id)
        edges <- try(string_db$get_interactions(ids), silent = TRUE)
        if (!inherits(edges,"try-error") && nrow(edges)>0) {
          edges <- edges |> dplyr::filter(from %in% ids & to %in% ids) |> distinct(from,to,.keep_all=TRUE)
          g <- graph_from_data_frame(edges[,c("from","to")], directed = FALSE)
          # derece -> hub
          degv <- sort(igraph::degree(g), decreasing = TRUE)
          hubs <- head(degv, 10)
          hub_df <- data.frame(STRING_id = names(hubs), degree = as.integer(hubs))
          # geri haritala isim
          hub_df$SYMBOL <- mp$gene[match(hub_df$STRING_id, mp$STRING_id)]
          write.csv(hub_df, file.path(out_dir, "STRING_top10_hubs.csv"), row.names = FALSE)
          
          p_net <- ggraph(g, layout="fr") +
            geom_edge_link(alpha=.3) +
            geom_node_point(size=2) +
            geom_node_text(aes(label = mp$gene[match(name, mp$STRING_id)]),
                           repel=TRUE, size=2.6) +
            theme_void(base_size=12) + ggtitle("STRING PPI — Pompe DEGs (adj.P<0.05)")
          ggsave(file.path(plot_dir, "fig4_ppi_string_network.png"), p_net, width=10, height=8, dpi=300)
          
          p_hubs <- ggplot(hub_df, aes(x=reorder(SYMBOL, degree), y=degree)) +
            geom_col() + coord_flip() + theme_minimal(base_size=12) +
            labs(title="PPI Hub genler (derece)", x=NULL, y="Derece")
          save_png(p_hubs, "fig4_ppi_hubs_bar.png", w=6.5, h=4.8)
        }
      }
    }
  }
}

# ============================================================
# FIGÜR 4F — multiMiR VALIDATED ağ + özet barplotlar
# ============================================================
RUN_MIR <- TRUE
if (RUN_MIR) {
  ok <- requireNamespace("multiMiR", quietly = TRUE)
  if (!ok) { warning("multiMiR yok; miRNA hedef ağı atlandı.") } else {
    library(multiMiR)
    sig_genes <- unique(tt_sym$SYMBOL[tt_sym$adj.P.Val < FDR_THRESH])
    if (length(sig_genes) > 0) {
      mm <- try(multiMiR::get_multimir(org="hsa", target=sig_genes, table="validated", summary=FALSE), silent = TRUE)
      if (!inherits(mm,"try-error")) {
        df <- try(multiMiR::multimir_results(mm), silent = TRUE)
        if (!inherits(df,"try-error") && !is.null(df) && nrow(df)>0) {
          # Hedef/sütun isimleri
          tgt_col <- intersect(c("target_symbol","target","target.gene","SYMBOL"), names(df))[1]
          mir_col <- intersect(c("mature_mirna_id","miRNA","mirna","mirna_id","miRNA_ID","mature_mirna_acc"), names(df))[1]
          if (!is.na(tgt_col) && !is.na(mir_col)) {
            df[[tgt_col]] <- toupper(trimws(as.character(df[[tgt_col]])))
            df[[mir_col]] <- trimws(as.character(df[[mir_col]]))
            df <- df[df[[tgt_col]] %in% sig_genes, , drop = FALSE]
            
            # barplotlar
            gene_freq <- as.data.frame(table(df[[tgt_col]])); names(gene_freq) <- c("Gene","Count")
            mir_freq  <- as.data.frame(table(df[[mir_col]]));  names(mir_freq)  <- c("miRNA","Count")
            p_g <- ggplot(head(gene_freq[order(-gene_freq$Count),], 20),
                          aes(reorder(Gene, Count), Count)) + geom_col() + coord_flip() +
              theme_minimal(base_size=12) + labs(title="Validated: En çok hedeflenen genler", x=NULL, y="miRNA sayısı")
            p_m <- ggplot(head(mir_freq[order(-mir_freq$Count),], 20),
                          aes(reorder(miRNA, Count), Count)) + geom_col() + coord_flip() +
              theme_minimal(base_size=12) + labs(title="Validated: En çok gen hedefleyen miRNA'lar", x=NULL, y="Gen sayısı")
            save_png(p_g, "fig4f_validated_top_genes.png", w=6.5, h=5.2)
            save_png(p_m, "fig4f_validated_top_miRNAs.png", w=6.5, h=5.2)
            
            # küçük alt-ağ (top30 x top30)
            suppressPackageStartupMessages({ library(igraph); library(ggraph) })
            tg30  <- head(gene_freq$Gene[order(-gene_freq$Count)], 30)
            mir30 <- head(mir_freq$miRNA[order(-mir_freq$Count)], 30)
            edges <- df[df[[tgt_col]] %in% tg30 & df[[mir_col]] %in% mir30, c(tgt_col, mir_col)]
            names(edges) <- c("Gene","miRNA")
            edges <- unique(na.omit(edges))
            if (nrow(edges) >= 2) {
              g <- igraph::graph_from_data_frame(edges, directed = FALSE)
              p_net <- ggraph::ggraph(g, layout="fr") +
                ggraph::geom_edge_link(alpha=.35) +
                ggraph::geom_node_point(size=3) +
                ggraph::geom_node_text(aes(label = name), repel = TRUE, size = 2.8) +
                theme_void(base_size=12) + ggtitle("Validated miRNA–Gen ağı (alt küme)")
              ggsave(file.path(plot_dir, "fig4f_validated_network.png"), p_net, width=10, height=8, dpi=300)
            }
          }
        }
      }
    }
  }
}

# ============================================================
# FIGÜR 6 — ssGSEA skorlarıyla örnek ayrışması (Hallmark) + PCA/UMAP
# ============================================================
{
  # Hallmark setleri ile örnek bazlı skor
  hm_t2g <- msigdbr(species="Homo sapiens", collection = "H") |>
    transmute(term = gs_name, gene = toupper(gene_symbol)) |> split(.$gene, .$term)
  ssg_h <- GSVA::gsva(as.matrix(expr_gene), hm_t2g, method = "ssgsea", ssgsea.norm = TRUE, verbose = FALSE)
  
  # En çok ayrışan 15 set (Pompe-Control ort. farkına göre)
  grp <- groups[colnames(ssg_h)]
  d  <- apply(ssg_h, 1, function(x) mean(x[grp=="Pompe"]) - mean(x[grp=="Control"]))
  top15 <- names(sort(abs(d), decreasing = TRUE))[seq_len(min(15, length(d)))]
  
  # Isı haritası
  ann <- data.frame(Group = grp, row.names = names(grp))
  pheatmap::pheatmap(ssg_h[top15,,drop=FALSE], annotation_col = ann, show_colnames = FALSE,
                     main = "Hallmark ssGSEA — en farklı 15 set",
                     filename = file.path(plot_dir, "fig6_hallmark_ssgsea_heatmap.png"),
                     width = 9, height = 7)
  
  # ssGSEA skorlarının PCA/UMAP'ı
  pc <- prcomp(t(ssg_h), scale. = TRUE)
  p_pca_ssg <- ggplot(data.frame(PC1=pc$x[,1], PC2=pc$x[,2], Group=grp, Sample=names(grp)),
                      aes(PC1, PC2, color=Group, label=Sample)) +
    geom_point(size=2) + theme_bw(base_size=12) + labs(title="PCA — Hallmark ssGSEA (örnekler)") +
    ggrepel::geom_text_repel(size=2.6, max.overlaps=20, show.legend = FALSE)
  save_png(p_pca_ssg, "fig6_pca_ssgsea.png", w=7.5, h=6)
  
  um <- umap::umap(t(ssg_h), n_neighbors = 8, random_state = 123)
  p_umap_ssg <- ggplot(data.frame(UMAP1=um$layout[,1], UMAP2=um$layout[,2], Group=grp, Sample=names(grp)),
                       aes(UMAP1, UMAP2, color=Group, label=Sample)) +
    geom_point(size=2) + theme_minimal(base_size=12) + labs(title="UMAP — Hallmark ssGSEA (örnekler)") +
    ggrepel::geom_text_repel(size=2.6, max.overlaps=20, show.legend = FALSE)
  save_png(p_umap_ssg, "fig6_umap_ssgsea.png", w=7.5, h=6)
}

message(">> 'Hemen Kullan' Pompe figürleri üretildi. PNG'ler = ", normalizePath(plot_dir))




#HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH





#IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII



#KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
2) “Sanki hücre hattında denemiş gibi” in-silico değerlendirme yolları

Aşağıdaki mini bloklar senin mevcut boru hattınla uyumlu (ör: tt_sym, deg, expr_gene oluşturuyorsun).

2.a) İmzanı (up/down genler) LINCS L1000 ile eşleştir (ilaç önerisi)

Sen zaten msigdbr kullanıyorsun; CP:LINCS setleriyle enricher yapıp “UP’ı DOWN’la, DOWN’u UP’la” eşleştir:

Sen zaten msigdbr kullanıyorsun; CP:LINCS setleriyle enricher yapıp “UP’ı DOWN’la, DOWN’u UP’la” eşleştir:
  
  library(msigdbr); library(clusterProfiler); library(dplyr); library(stringr)

msig_lincs <- msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:LINCS_L1000")
lincs_up   <- split(toupper(msig_lincs$gene_symbol[str_ends(msig_lincs$gs_name, "_UP")]),
                    msig_lincs$gs_name[str_ends(msig_lincs$gs_name, "_UP")])
lincs_down <- split(toupper(msig_lincs$gene_symbol[str_ends(msig_lincs$gs_name, "_DN")]),
                    msig_lincs$gs_name[str_ends(msig_lincs$gs_name, "_DN")])

up_gen   <- unique(deg$SYMBOL[deg$logFC > 0])
down_gen <- unique(deg$SYMBOL[deg$logFC < 0])

# İmzanı tersine çevirecek bileşikler:
en_up_dn <- enricher(up_gen,   TERM2GENE = lincs_down, pAdjustMethod = "BH")
en_dn_up <- enricher(down_gen, TERM2GENE = lincs_up,   pAdjustMethod = "BH")


Çıkan zengin set adlarından ilacın adını ayıklayıp (örn. _UP/_DN temizle) “imzayı tersleyen” adayları raporlayabilirsin.



2.b) İfade imzanı DepMap’te skorla ve CRISPR duyarlılığı ile ilişkilendir

Pompe imzan için ssGSEA skoru hesaplayıp (cell-line bazında) belirli gen bağımlılıkları veya doku kökenleriyle ilişki kur:
  
  BiocManager::install("GSVA"); library(GSVA)

# expr_depmap: genes x cell_lines (depmap_expression dan)
common_genes <- intersect(rownames(expr_depmap), toupper(rownames(expr_gene)))
scores <- gsva(expr_depmap[common_genes, ], list(POMPE_SIG = toupper(deg$SYMBOL)), method="ssgsea")

# CRISPR bağımlılık korelasyonu (ör. GAA geni veya otofaji genleri):
gaa_dep <- crispr %>% dplyr::filter(gene == "GAA") %>% dplyr::select(cell_line, gene_effect)
sc <- as.numeric(scores["POMPE_SIG", match(gaa_dep$cell_line, colnames(scores))])
cor.test(sc, gaa_dep$gene_effect, method = "spearman")

2.c) “Benim verim için ilaç duyarlılığı tahmini” (GDSC/CTRP ile eğitilmiş modeller)

oncoPredict (yeni & önerilir) veya pRRophetic (klasik).
Bunlar GDSC/CTRP cell-line modelleriyle eğitilip senin örneklerinin (hücre hattı ya da doku) ilaç yanıtını tahmin eder.

# oncoPredict (özet kurulum)
install.packages("oncoPredict")
library(oncoPredict)

# Eğitim (GDSC) – paket fonksiyonları eğitim setini indirebiliyor
# Ardından test verisi: expr_gene (gen x sample, SYMBOL)
pred <- oncoPredict::calcPhenotype(
  trainingExprData = NULL, trainingPtype = NULL,   # paket içi hazır verileri kullan
  testExprData     = expr_gene,                    # senin örneklerin
  batchCorrect = TRUE, powerTransformPhenotype = TRUE
)
head(pred)   # ilaç bazında tahminler (AUC/IC50 ölçeği)


Not: Bu yaklaşım “cell line’da test edilmiş gibi” bir in-silico tahmindir; gerçek ıslak-lab doğrulaması değildir.






######################################################################################################

## ====================
## GO Analizi (enrichGO)
## ====================

# Gerekli paketler
suppressPackageStartupMessages({
  library(clusterProfiler)
  library(org.Hs.eg.db)
  library(dplyr)
})

# Anlamlı genlerin (adj.P.Val < 0.05) SYMBOL listesini hazırla
sig_genes <- tt_gene %>%
  filter(adj.P.Val < 0.05, !is.na(SYMBOL), nzchar(SYMBOL)) %>%
  pull(SYMBOL) %>%
  unique() %>%
  toupper()

# SYMBOL -> ENTREZ ID dönüşümü (GO analizi için)
eg <- AnnotationDbi::select(org.Hs.eg.db, keys = sig_genes,
                            keytype = "SYMBOL", columns = "ENTREZID")
eg_ids <- unique(na.omit(eg$ENTREZID))

# Arka plan evreni oluştur (tüm test edilen genler)
bg_genes <- tt_gene %>%
  filter(!is.na(SYMBOL), nzchar(SYMBOL)) %>%
  pull(SYMBOL) %>%
  unique() %>%
  toupper()
bg_eg <- AnnotationDbi::select(org.Hs.eg.db, keys = bg_genes,
                               keytype = "SYMBOL", columns = "ENTREZID")
bg_ids <- unique(na.omit(bg_eg$ENTREZID))

# enrichGO (BP – Biological Process)
ego_bp <- enrichGO(
  gene          = eg_ids,
  universe      = bg_ids,
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "BP",
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.05,
  qvalueCutoff  = 0.2,
  readable      = TRUE
)

# Sonuçları kaydet
if (!is.null(ego_bp) && nrow(as.data.frame(ego_bp)) > 0) {
  write.csv(as.data.frame(ego_bp), file = file.path(root_dir, "results", "GO_enrich_BP.csv"), row.names = FALSE)
}

# Görsel (ilk 20 yol)
if (!is.null(ego_bp) && nrow(as.data.frame(ego_bp)) > 0) {
  library(enrichplot)
  pgo <- barplot(ego_bp, showCategory = 20, title = "GO BP Enrichment")
  ggsave(filename = file.path(root_dir, "results", "GO_enrich_BP_barplot.png"), plot = pgo, width = 8, height = 6)
}

################################################################################################################
